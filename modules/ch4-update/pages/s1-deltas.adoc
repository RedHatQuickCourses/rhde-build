:time_estimate: 13

= Apply, and Rollback Updates to Edge Devices

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Understand how edge devices consume operating system updates from OSTree repositories.

WARNING: Work In Progress

== Device Updates

Edge devices running RHEL for Edge retrieve operating system updates as new system images. They do not download individual package updates from RPM repositories, like package-based RHEL deployments do. You cannot end up in a state where some updates were applied but others weren't. You either update the entire system image or do not update anything.

image::s1-deltas-fig-1.svg[title="End of an edge device update workflow"]

RPM-OSTree keeps two system images side-by-side in a system, and only switches from the current to the new system image with a reboot -- constrast that with RPM package updates, which alter files which are in use by running processes and may produce unpredictable results.

You can rollback an RPM-OSTree system into a previous known good image -- constrast that with rolling back an update of multiple RPM packages. With package-based systems, you can select an older kernel at boot, but you cannot easily revert all system binaries and dependency libraries, which depend on the kernel version. With an image-baed system using RPM-OStree you revert to the the kernel, libraries, and binaries of a previous system image all at one.

You must use the `rpm-ostree` command on an edge device to download (stage) a new system image, and them reboot the system to deploy the new image. The same command allows you to rollback to the previous system image. In case you download further system updates, the one not currently active is discarded to give room to the new updates, so there's at most two system images in an edge devices and you don't need to prune old updates nor disk exhausting disk space on the device.

Both on disk and during download, RPM-OStree takes advatage of OSTree capabilities to not store and download files which didn't change between the current and the new system image. But the process of checking file changes can still take multiple network transactions and be slow for systems with low-bandwidth or high-latency network connections. In that case, you're advised to crate a static delta on your OSTree repository for faster download of updates.

== Device Updates and Configuration or Application Data

RPM-OSTree allows writes to only `/etc` and `/var`, which are treated in different ways during a system update:

*  Files in `/var` are only touched at first boot, when they're copied from the system image to the writable file system, but updates keep the contents in `/var` unchanged.

* Files in `/etc` are updated with a three-way merge process: the current `/etc` contents are compared with the current system image; differences are applied a copy of the contents of `/etc` from the new system image; and the result saved to the writable file system.

The goal is, on one side, to preserve application data in `/var` across system updates, while at the same time enabling applications to include initial data in a system image; and on the other side, enable new system images to bring new configuration files and change configuration defaults, while preserving local customizations applied to the running system.

If a system update requires changes to application data, for example migrating data to a new database schema, this is responsability of the application. It could run a first boot job to perform the database migration or use any other strategy. Just do not rely on RPM-OSTree itself to make application data compatible with a new version of an application and its dependencies.

== Building Update Images with Image Builder

An update image is just a regular edge commit image produced by Image Builder. It contains a single OSTree commit which you copy (`ostree pull-local`) to a remote OSTree repository which provides updates to edge devices. But, if you build the update image the same way you did for the first image, used to provision edge devices, that image has a commit with no parent and will clean the history of its OSTree branch when pulled into a remote OSTree repository, causing issues for edge devices that need to rollback to previous images and eliminating the possibility of creating static deltas for edge devices on slow networks.

You must build all updates of edge images with a reference to a remote OSTree repository and a branch, so the new edge commit image records the current head of the branch as its parent. Then the edge commit image will include only changes relative to that parent and be pulled into an OStree repository without cleaning its branch history.

== Distribution of Edge Image Updates

[ Image of multiple repos and promotion ]

As you develop and test applications, which you embed in an RHEL for Edge system image, you may use multiple OSTree repositories. 

You do not need OSTree and Image Builder for the inner loop: you just test your applications on regular RHEL. But, at some moment, you need to perform integration testing using an environment that is as close as possible to your edge devices. You must ensure your image contains the right dependencies and customizations for your applications, so you must build an image and test it, probably using virtual machines.

Assuming your RHEL for Edge system image passes integration tests, you might perform more involved tests, such as performance or functional testing, before you finally declare your system image is clear for production. 

At each of these states, you may use different OSTree repositories, and copy edge images, that is their OSTree commits, from one repository to the next. Finally, you could maintain multiple repositories with the copies of the same production images, for fault-tolerance or to serve different geographical regions. This all works because OSTree commit IDs are unique and do not change as you copy them from one repository to another.

What if an edge commit image does not pass tests and is never delivered to production? Just build the next iteration using the same parent OSTree commit as the failed image. That way it replaces the previous iterations on the intermediate OSTree repositories you use for testing, and if it passess all tests it can be added to production repositories.

So, instead of using the latest image (latest OSTree commit) as the parent of the next image you build for testing, you keep using the latest image successfuly delivered to production as the patent of all test images, until one of them is promoted all the way to production and becomes the new latest. A way of enforcing that is using, during image build, a reference production OSTree repository, even if that image might never be pulled into the production repository.

It is perfectly fine if an edge commit image contains a remote which points to an OSTree repository which is not the one serving it.During testing you usually deploy a test VM (or phisical device) as if it's being provisioned for the first time. But, if you must test an update process, such as data schema migration, you may override the remote reference on the test machine before applying an update.

IMPORTANT: Edge systems provisioned using edge installer images are *not* configured with a valid OSTree remote. You must configure them before being able to apply any system update.

Unlike Git, which is designed to keep a complete history of changes to source code, OSTree is *not* designed to keep a complete history of binary system images. That means you must be careful to preserve the chain of each commit to its parent.

== Pruning OSTree Repositories

You do not need to prune the local OSTree repository of an edge device because RPM-OStree does that automatically, always keeping at most two system images in the device. Deduplication of OSTree content happens at the file level, not at the branch or commit level, so you can safely prune older commits without losing files that didn't change and are still in use by more recent commits.

Os production or test repositories it may be necessary to implement a process for pruning old commits, based on count, age, or whatever other criteria. Else those repositories may grow unbounded and some day be out of disk space.

OSTree commits are considered derived data: the source of truth of an edge commit image is not the image itself, but the source code used to build its applications, its blueprint, and package list from RPM repositories. It is assumed that you could rebuild an old edge image exactly as it were, by providing the same inputs. So, unlike a source code repository, there is no need to keep historical data on an OSTree repository.

You may need manually prune an OStree repository of its latest commit. Remember that happens automatically in a test repository, when you pull in a newer test image. But what if an image was promoted all the way into production, and only then you find an issue? Pruning the latest image in a branch of a production repository prevents more edge devices from pulling that image as a system update. For devices that already applied the update, you rollback them to the previous image. And, when you fix whatever issue required you to remove the latest commit, you provide a fix as a new system image, which is just another image update to all edge devices. As you prune the ostree commit from your production repositories, you also prune it from your test repositories, so no new image will use it as their parent.

== OSTree Static Deltas

OSTree static delta allow edge devices with bad network connectivity to download system updates.

The standard process for downloading OSTree updates is similar to what Git, DNF, and other packaging systems perform, which is basically a file-by-file check. If a system already has the file, move to the next. If it doesn't, download it. That process requires many network transactions, as a device checks files on a remote repository. It may not require lots of bandwidth, as each file check sends very little data over the network, but if anything delays each request and response, the overall update may take a long time.

OSTree offers the possibility of precomputing and storing static deltas between any two commits as part of an OSTree repository.OSTree clients will discover and use these precomputed deltas, called *static deltas*, transparently, saving network bandwidth and reducing the time to download updates.

[ figure of multiple commits and deltas, and clients downloading either a commit or a delta ]

If it happens that an edge device skips an update, for example because it was offline for too long, It will just download changes the usual way, without using the deltas between the current and the previous commit. If you expect this to be a frequent event, you could build static deltas between the current latest and many previous commits: one delta for latest → latest-1, another delta for latest → latest-2, one more for latest → latest-3, and so on.

Each static delta takes up disk scape on an OSTree repository server, but you consider that disk space on a server is cheaper than at an edge device or than network bandwith.

Having static deltas also reduces the memory and CPU requirements of both clients and servers when updating systems. If you consider that an OSTree server has a potentially large population of client edge devices, compared to the population of developers using a Git repository, the efficiency gains can be large, not to mention a lower cloud bill for running your OSTree servers.

Precomputed static deltas also saves CPU from smaller edge devices while downloading and deploy system updates. The gains are wellcome by edge devices, which have slower CPUs and less memory than data center servers. This is also significant because edge devices are expected to contine performing their regular tasks while downloading (or staging) system updates.

In fact, static deltas may be so good for some devices and networks that some RPM-OStree users create empty deltas: they store the difference between a commit and nothing, which is is the entire commit. But that delta can be queried and downloaded as a single unit, instead of a file-by-file basis, preserving memory, CPU, and network capacity between an edge device and a remote OStree repository.

== OSTree Summary Files

Every time you update an OSTree repository with multiple branches, updates, and static deltas, you must also update its summary file. Most OSTree clients, such as RPM-OSTree, will check only that summary for information on remote repositories. If that file is outdated, such clients will not be aware of updates or static deltas.

You do not need a sumary file for provisioning edge systems or building edge commit images because they either work with a predefined commit, but its ID, or with whatever is the latest in a predefined branch. Those processes do not query a remote OSTree repository for the availability of other commits, deltas, or branches.

== Rebasing an Edge Device

It's common to use an OSTree banch to represent a major version of an operating system + applicatons, and major updates of each become different OSTree branches. This is consistent with the fact that you don't usually phase out a major application release immediately, but keep supporting it with updates and bugfixes for a while. You do not force all users to switch to the new major release at one.

An RHEL for Edge system can use the RPM-OStree rebase operation to switch between OSTree branches and thus update to a new operating system or application major release.

We are not performing rebases in the hands-on activities, as this is a somewhat rare event -- a major new release frequently requires a hardware refresh. We also do not exercise other RPM-OSTree features, such as applying a mutable layer over `/usr` to install RPM packages outside its system images, but we encourage people to use the `--help` option to explore the verbs of the `rpm-ostree` command and explore its possibilities.

== Next Steps

The final series of hands-on activties in this course builds, installs and rolls backs updates to edge system images using test VMs that were provisioned using different methods.
