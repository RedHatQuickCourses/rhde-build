<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Design, Build, and Publish Edge Images :: Building Red Hat Device Edge Images</title>
    <link rel="prev" href="s1-devices.html">
    <link rel="next" href="s4-install-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building Red Hat Device Edge Images</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-build/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header><div class="body">
<div class="nav-container" data-component="rhde-build" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building Red Hat Device Edge Images</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Build Operating System Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s1-devices.html">Introduction to Red Hat Device Edge</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s3-images.html">Design, Build, and Publish Edge Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s4-install-lab.html">Lab: Install Image Builder on a Development VM</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s5-blueprint-lab.html">Lab: Create and Manage Blueprints for Edge Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s6-compose-lab.html">Lab: Create and Manage Composes for Edge Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s7-ostree-lab.html">Lab: Publish Edge Images on Remote OSTree Repositories</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-test/index.html">Validate initial deployment of RHEL for Edge images in local VMs using virsh and cockpit</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-test/s2-boot-lab.html">Lab: Boot Edge VMs from Remote OSTree Repostories</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building Red Hat Device Edge Images</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building Red Hat Device Edge Images</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building Red Hat Device Edge Images</a></li>
    <li><a href="index.html">Build Operating System Images for Edge Devices</a></li>
    <li><a href="s3-images.html">Design, Build, and Publish Edge Images</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Design, Build, and Publish Edge Images</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>5 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Understand the characteristics of RHEL for Edge images and the workflows for building and publishing them.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Work In Progress
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_rhel_image_builder_service"><a class="anchor" href="#_the_rhel_image_builder_service"></a>The RHEL Image Builder Service</h2>
<div class="sectionbody">
<div class="paragraph">
<p>[ Maybe break this entire presentation into multiple lectures and interleave them with the labs ]</p>
</div>
<div class="paragraph">
<p>[ Add something on why it needs to be a system service and why it&#8217;s secure (unlike docker)]</p>
</div>
<div class="paragraph">
<p>The Image Builder tool is a system service in RHEL, named <strong>osbuild-composer</strong>, with which you interact by means of the <strong>composer-cli</strong> command-line client or the <strong>Composer</strong> Cockpit module. It can generate various types of system images, including edge images.</p>
</div>
<div class="paragraph">
<p>[ figure of image builder service, its clients, input blueprint, and output images ]</p>
</div>
<div class="paragraph">
<p>The Image Builder service in RHEL is not designed for remote clients, and it does not support creating system images, or <strong>composes</strong>, for operating systems different than the one it is running on. For example, you cannot use the Image Builder service from RHEL 9 to build a RHEL 8 nor a CentOS 9 Stream system image. Most likely, you will be running Image Builder in a VM and using SSH or Cockpit to interact with Image Builder on that VM.</p>
</div>
<div class="paragraph">
<p>You provide to Image Builder a blueprint using the <a href="https://toml.io/en/">TOML</a> syntax, which is very similar to INI files from Windows and Samba. A blueprint defines characteriscs of the system image, such as installed packages and enabled system services. It also enables customization of users, networking, and other system configurations, and not all of them are supported for edge images. You can think of a blueprint as a response file for the prompts and options you would get from the RHEL installation program, Anaconda.</p>
</div>
<div class="paragraph">
<p>An Image Builder blueprint should be independent of the target environment where you deploy the image. When you build a compose, Image Builder adds hardcoded customizations which depend on the image type. For example, if you build an Amazon Machine Image (AMI), Image Builder enables the Cloud-Init service and also adds the AWS Systems Manager client. You could use the same blueprint to build different types of composes, for example ISO images to boot a physical system and Qcow2 images for OpenStack private clouds.</p>
</div>
<div class="paragraph">
<p>The biggest benefit of using Image Builder, compared to generic Anaconda or Ansible automation, is the built-in knowledge about the needs of different target platforms such as cloud providers and hypevisors. It ensures your image contains all recommended settings and system services for working whell on each platform.</p>
</div>
<div class="paragraph">
<p>All blueprints and composes are kept in the Image Builder service storage, and you must upload blueprints to build composes, download blueprints to make changes, and download composes so you can publish them somewhere suitable as a boot source for your physical or virtual systems. As a convenience, Image Builder can upload images by itself to a limited set of remote image stores. For example, it can take AWS API credentials as input and upload AMI images to AWS S3 so you can use them to create AWS EC2 instances.</p>
</div>
<div class="paragraph">
<p>Depending on the target environment and the type of image, you can use different methods to perform additional installation-time (or day-1) customization of those images, for example Anaconda Kickstart files and Cloud-init. Or you could build your own workflow for adding local customizations to an image, for example by using an interactive application which runs during the first boot.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_edge_images_versus_package_based_systems"><a class="anchor" href="#_edge_images_versus_package_based_systems"></a>Edge Images Versus Package-based Systems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Regular compose types from Image Builder work the same as if you deploy RHEL from its installation media: they are package-based systems. After you install a physical system or boot a VM from these images, you manage it exactly the same way as if you installed the system from RHEL installation media.</p>
</div>
<div class="paragraph">
<p>Edge compose types, in contrast, are image-based systems. They assume most customizations are predefined in the system image, and that software updates are performed by installing another system image.</p>
</div>
<div class="paragraph">
<p>Consider the scenario of updating a system to mitigate a CVE vulnerability with the Apache Web Server. You would act differently on image-based systemas compared to traditional package-based systems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On regular RHEL, which is a package-based system, you would SSH into the system and use <code>dnf</code> to update the <code>httpd-server</code> package and its dependencies.</p>
</li>
<li>
<p>On RHEL for Edge, which is an image-based system, you would use Image Build to build a new system image that includes the updated <code>httpd-server</code> package and dependencies, and them deploy the new system image on the system.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Installing and updating RHEL for Edge systems requires different approaches from the RHEL systems you are used to, while preserving compatibility with applications and hardware. You can develop and test applications using "regular RHEL" and later depeloy them in RHEL for Edge systems.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_edge_images_and_rpm_ostree"><a class="anchor" href="#_edge_images_and_rpm_ostree"></a>Edge Images and RPM-OSTree</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Edge images from Image Builder are based on the OSTree technology, which configures the root filesystem as read-only. Well, not the true root file system, it&#8217;s actually a chroot, but you learn those details later in this course. In an OSTree-based system, you cannot change a system file, not even as root, except by deploying a new system image an rebooting into the new image.</p>
</div>
<div class="paragraph">
<p>OSTree can keep multiple system images side-by-side in a system, so downloading updates does not affect a running system&#8201;&#8212;&#8201;constrast that with RPM package updates, which can alter files which are in use by running processes and produce unpredictable results.</p>
</div>
<div class="paragraph">
<p>You can reboot an OSTree system into any of the available system images, making it trivial to rollback a system update to a previous known good image&#8201;&#8212;&#8201;constrast that with rolling back an update of multiple RPM packages. With package-based systems, you can select an older kernel at boot, but you cannot easily revert all system binaries which depend on the kernel version.</p>
</div>
<div class="paragraph">
<p>OSTree allows writes to only <code>/etc</code> and <code>/var</code>, which are treated in different ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Files in <code>/var</code> are only touched at first boot, when they&#8217;re copied from the system image to the writable file system, but updates keep the contents in <code>/var</code> as they are.</p>
</li>
<li>
<p>Files in <code>/etc</code> are updated with a three-way merge process: the current <code>/etc</code> contents are compared with the original system image, differences are applied to the contents of <code>/etc</code> from the new system image, and the result saved to the writable file system.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The goal is, on one side, to preserve application data in <code>/var</code> across system updates, and on the other side, enable new system images to bring new configuration files and change configuration defaults, while preserving local customizations applied to the running system.</p>
</div>
<div class="paragraph">
<p>[ figure of read-only /usr and read-write /etc and /var. Also /sysroot? ]</p>
</div>
<div class="paragraph">
<p>The OSTree technology is not designed to be usable by itself, but to be infrastructure under higher-level Linux distribution tooling. In RHEL, the higher level infrastructure is RPM-OSTree, which builds OSTree system images from RPM packages.</p>
</div>
<div class="paragraph">
<p>RPM-OSTree also enables installing RPM packages in an image-based by creating a file system layer of local customizations, which you can either keep or discard during system updates. It is not expected that edge systems abuse that feature of RPM-OSTreem but it can be handy during development and troubleshooting of edge images.</p>
</div>
<div class="paragraph">
<p>Image Builder users do not interact with the RPM-OSTree and OSTree tooling directly, at least not to build edge images. But they must interact with RPM-OSTree to distribute and apply updates to edge systems.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_edge_image_types"><a class="anchor" href="#_edge_image_types"></a>Edge Image Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The only indispensable type of edge image (or edge compose) from Image Builder is the <strong>edge commit image</strong>. It provides an OSTree image, called a <strong>OSTree commit</strong>, as a single compressed archive.</p>
</div>
<div class="paragraph">
<p>That OSTree commit can be pushed into an OSTree repository, and then consumed by a RHEL installation image, with a custom Kickstart file, to deploy into a physical system or virtual machine. This is a suggested workflow for developer testing and CI/CD pipelines.</p>
</div>
<div class="paragraph">
<p>You can also use Image Builder to take an OSTree commit and build one of the following kinds of derived edge composes:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Edge installer images</dt>
<dd>
<p>They include a RHEL installer and an OSTree commit, so you can boot a physical system and install the system image, instead of using the RHEL installation media.</p>
</dd>
<dt class="hdlist1">Edge cloud images</dt>
<dd>
<p>They are directly bootable by cloud or hypervisor platforms and include an already deployed OSTree commit.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Both types of derived edge composes can install an edge system without network access to an OSTree repository, and you can use either the standard RHEL installation image or an edge installer image to install edge systems from network boot instead of booting from local media.</p>
</div>
<div class="paragraph">
<p>[ figure of RHEL ISO + remote OSTree commit and edge installer image with embeded OSTree commit ]</p>
</div>
<div class="paragraph">
<p>Whatever the boot method and compose type you use for installing an edge system, it requires access to a remote OSTree repository to fetch and deploy system updates. Image Builder cannot build anyhing similar to an "edge update image", which would boot from local media or network boot and apply a system update. Such feature is currently in development, as part of the Red Hat In Veichle Operating System (RHIVOS), but it is not supported yet by Image Builder on RHEL.</p>
</div>
<div class="paragraph">
<p>In fact, all bootable types of edge composers supported by Image Builder are preconfigured with an OSTree remote, which points to an OSTree repository server, except for the <strong>edge container image</strong>. This is a special type of compose designed to run as a Linux container which serves an OSTree commit over HTTP. It is intended as a quick way for a developer to provision a remote OSTree repository to build and test edge installer images, but it is not designed for long term usage nor for serving system updates.</p>
</div>
<div class="paragraph">
<p>In this course, you will NOT use edge container composes, you will instead learn how to configure and manage remote OSTree repositories so you can provide system updates to edge devices.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_publishng_ostree_commits"><a class="anchor" href="#_publishng_ostree_commits"></a>Publishng OSTree Commits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>OSTree is, conceptually, very similar to Git: both are designed to manage changes to file trees as atomic units, providing transactional updates and rollbacks to those trees. Both are also designed to manage multiple concurrent branches and to be efficient on both disk space and network bandwidth when handling deltas between two versions (or two commits) of the same file tree.</p>
</div>
<div class="paragraph">
<p>Why not just using Git? OSTree adds the following features, which are required to manage bootable Linux file systems but are not needed to manage application source code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Recording SELinux labels and POSIX extended attributes</p>
</li>
<li>
<p>Installing booloaders, Linux Kernels, and initial ramdisks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similar to Git, a client OSTree system contains a copy (or a clone) of a remote OSTree repository, and it can pull changes from the remote repository. Unlike Git, OSTree is optimized for handling large binary files, as opposed to small text files.</p>
</div>
<div class="paragraph">
<p>Another practical difference between OSTree and Git is the fact that OSTree provides no specialized server software: OSTree repositories are just files serverd by a standard HTTP server. You manage OSTree repositories using local file system access, and remote access over HTTP works only for downloading (pulling) updates from a remote to a local repository.</p>
</div>
<div class="paragraph">
<p>While this means that managing remote OSTree repositories requires more effort than with Git, it also means you don&#8217;t need to learn how to deploy and manage special server software: you just need to learn how to use the client-side OSTree tools. Actually you only need to learn the client tools from the higher-level abstraction above OSTree, which is RPM-OSTree in the case of RHEL for Edge,.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ostree_static_deltas"><a class="anchor" href="#_ostree_static_deltas"></a>OSTree Static Deltas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>[ Move this heading to the update topic? ]</p>
</div>
<div class="paragraph">
<p>Unlike Git, OSTree is designed to be able to easily and cleanly discard history, on the assumption that all operating system binaries in a commit can be recreated from their source code. An OSTree repository is not intended for long-term change tracking and auditing: these are best done on the source code rather than on the derived binaries.</p>
</div>
<div class="paragraph">
<p>OSTree repositories can include OSTree commits with no change history between them, and are nonetheless able to deduplicate file contents between commits on both on local and remote repositories. OSTree also optimizes network traffic by sending only deltas between repositories. So you can build many OSTree commits in a development system, using its local repository, and only promote for production usage, in a remote repository, a few commits which passed unit tests and functional tests.</p>
</div>
<div class="paragraph">
<p>But, as Git users know, computing deltas and transfering them on-demand, one file at a time, is not the most efficient method. I requires multiple network transactions and incurrs in lots of protocol overhead. OSTree offers the possibility of precomputing and storing static deltas between two commits as part of an OSTree repository.</p>
</div>
<div class="paragraph">
<p>OSTree clients will discover and use these precomputed deltas, called <strong>static deltas</strong>, transparently, saving network bandwidth and reducing the time to download updates. The savings are even more noticeable in high-latency networks.</p>
</div>
<div class="paragraph">
<p>[ figure of multiple commits and deltas, and clients downloading either a commit or a delta ]</p>
</div>
<div class="paragraph">
<p>Having static deltas also reduces the memory and CPU requirements of both clients and servers when updating systems. If you consider that an OSTree server has a potentially large population of client edge devices, compared to the population of developers using a Git repository, the efficiency gains can be large, not to mention a lower cloud bill for running your OSTree servers.</p>
</div>
<div class="paragraph">
<p>Precomputed static deltas also saves CPU from smaller edge devices while downloading and deploy system updates. The gains are wellcome by edge devices, which have slower CPUs and less memory than data center servers. This is also significant because edge devices are expected to contine performing their regular tasks while downloading (or staging) system updates.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_naming_blueprints_and_composes"><a class="anchor" href="#_naming_blueprints_and_composes"></a>Naming Blueprints and Composes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Image Builder allows you to give human-readable names to blueprints, but it allways identifies images or composes using UUIDs. A compose refers to a specific build of a blueprint, so there could me multiple composes for the same blueprint. For example, you could build a new compose from an existing blueprint to create a new image with RPM package updates from RHEL.</p>
</div>
<div class="paragraph">
<p>Image Builder maintains not only the image data for a compose, but also metadata such as package lists and build logs. Using the compose metadata, it is easy to compare two composes from the same blueprint and see what changed in the resulting image.</p>
</div>
<div class="paragraph">
<p>[ Need more&#8201;&#8212;&#8201;concepts. docs/upstream links, or maybe just more highlight as heading or def lists&#8201;&#8212;&#8201;to blueprints and composes. Trying to postpone details to RHDE-2-4 ]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_composer_cli_client"><a class="anchor" href="#_the_composer_cli_client"></a>The Composer CLI client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>composer-cli</code> command provides the Image Builder command-line client. It sumbits requests to the Image Builder service through the <code>/run/weldr/api.socket</code> UNIX socket, wich is accessible to the <code>weldr</code> group. So, any user that is member of the <code>weldr</code> group can build RHEL for Edge images using the Image Builder service.</p>
</div>
<div class="paragraph">
<p>The general syntax of Image Builder CLI client commands consists of an <em>object</em> and a <em>verb</em>, where object is an entity mangaged by Image Builder, such as <code>blueprints</code>, <code>compose</code>, and <code>projects</code>, and verb is an action to perform on the entity or set of entities.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">composer-cli <em>object</em> <em>verb</em> [<em>options</em>] [<em>arguments</em>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not all commands start with an object, sometimes there&#8217;s just a verb.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>The <code>compose</code> object is singular, while most other objects, such as <code>blueprints</code> and <code>projects</code>, are plural.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, the following command lists all blueprints known to Image Builder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ <strong>composer-cli blueprints list</strong></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following command lists the types of composes that Image Builder recognizes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ <strong>composer-cli compose types</strong></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <code>--help</code> option with any object or verb, and you can also use the <code>help</code> command, so all the following are examples ways of getting online help from the Image Builder CLI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ <strong>composer-cli help</strong>
$ <strong>composer-cli --help</strong>
$ <strong>composer-cli help blueprints</strong>
$ <strong>composer-cli blueprints --help</strong>
$ <strong>composer-cli help blueprints list</strong>
$ <strong>composer-cli blueprints list --help</strong></code></pre>
</div>
</div>
<div class="paragraph">
<p>Take your time to study the on-line help of the Image Builder CLI. There are some operations there which are not available from the Cockpit module.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_composer_cockplit_module"><a class="anchor" href="#_the_composer_cockplit_module"></a>The Composer Cockplit Module</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Composer Cockpit module provives the Image Builder web user interface. It adds an <strong>Image Builder</strong> item to the left navigation pane of the Cockpit user interface with three tabs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Blueprints</dt>
<dd>
<p>Manages blueprints and creates images from blueprints.</p>
</dd>
<dt class="hdlist1">Images</dt>
<dd>
<p>Manages images and access the build logs from creating an image.</p>
</dd>
<dt class="hdlist1">Sources</dt>
<dd>
<p>Manages package repositories used to download RPM packages from RHEL and third-party applications.</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/cockpit-image-builder.png" alt="cockpit image builder">
</div>
<div class="title">Figure 1. The Composer Cockpit module in the blueprints page.</div>
</div>
<div class="paragraph">
<p>Notice that the Image Builder CLI uses the <code>compose</code> command to refer to images, while the Image Builder web UI uses the term "image" to refer to composes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/cockpit-image-builder-images.png" alt="cockpit image builder images">
</div>
<div class="title">Figure 2. The Composer Cockpit module in the images page, which lists composes.</div>
</div>
<div class="paragraph">
<p>Notice that the Image Builder web UI is designed for large monitors and requires wide horizontal resolution, else headings and data may be truncated in the images page.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_rpm_ostree_tooling"><a class="anchor" href="#_the_rpm_ostree_tooling"></a>The RPM-OSTree tooling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>rpm-ostree</code> command fetches and deploys system image updates from a remote OSTree repository, including performing any bootloader and kernel changes required by the new image.</p>
</div>
<div class="paragraph">
<p>A system image is downloaded and staged without affecting the running system. The new system image is only effective after a reboot.</p>
</div>
<div class="paragraph">
<p>RPM-OSTree keeps the previous system image unchanged on disk and can rollback to it, which also requires a reboot.</p>
</div>
<div class="paragraph">
<p>You can query the RPM database on the current system image, but you cannot install and update packages using <code>yum</code> and <code>dnf</code> commands. You must use the <code>rpm-ostree</code> command to first enable an overlay layer to record changes to the system, and them install new packages or update packages from the current system images.</p>
</div>
<div class="paragraph">
<p>It is possible ot update the system image and keep the overlay, as long as the overlay does not include packages with releases olde than the new system image.</p>
</div>
<div class="paragraph">
<p>In this course, we will not teach the use of overlays and managing packages on RHEL for Edge. We focus on building and updating system images.</p>
</div>
<div class="paragraph">
<p>[ Either add an introduction to the syntax of the rpm-ostree command, or move this heading to another topic ]</p>
</div>
<div class="paragraph">
<p>[ Do we need to introduce the ostree command? For example, can I check the integrity of an ostree commit (or edte commit image) from rpm-ostree aline? ]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_steps"><a class="anchor" href="#_next_steps"></a>Next Steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that you was introduced to the essential concepts of RHEL for Edge, a series of hands-on activties install and configure Image Builder in a test system and build simple edge images. Later in this course you will test those edge images using local VMs, and them update those VMs to use new system images.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="s1-devices.html">Introduction to Red Hat Device Edge</a></span>
  <span class="next"><a href="s4-install-lab.html">Lab: Install Image Builder on a Development VM</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
